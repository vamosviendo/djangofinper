-   REVISAR métodos __str__ y __repr__ de todas las cuentas (son un asco).

-   Empezar a pensar vistas y formularios de entrada_
    -   Carga cuenta nueva
    -   Carga categoría nueva
    -   Carga movimientos (la que vamos a usar todo el tiempo, así que especial
        cuidado)
        
* finper/tests.py
    class AccountModelTest(TestCase)
        def test_balance_against_initial_balance(self):
        def test_balance_against_initial_balance_random_values(self):
        
        Reemplazar bucle for por accin.movements_in.aggregate(Sum('amount')?

* Ver cuál es el comportamiento cuando se elimina o cuando se modifica un movimiento.
  Al eliminarse, deberían desaparecer de movements_in en Account y "restarse" de
  Account.balance.
  Al modificarse el monto, debería modificarse también Account.balance.
    PROBLEMA:
    Dado un Movement mov, ya existente
    cuando se asigna un nuevo valor a mov.amount, al salvarse el movimiento 
    modificado, debería restarse del saldo de account_in el valor anterior y
    sumarse el valor actual (o bien, sumar/restar la diferencia entre el valor
    anterior y el valor después de la asignación).
    Ahora bien.
    Una vez hecha la asignación, ¿cómo hago para saber el valor anterior de 
    mov.amount? 
    
    Override = por medio de __setattr__()
    Para que al asignarse un valor a un campo, se guarde o se devuelva el valor
    anterior
    (no sé si tiene sentido esto que estoy diciendo, pero creo que sí)
    
    